# Implementation Progress

This file tracks the completion status of all implementation tasks for the Car Maintenance Tracker project.

## Purpose

Use this file to:
- Track which tasks have been completed
- Maintain a clear record of project progress
- Add completion dates and any important notes about implementation

## How to Use

When a task is completed:
1. Add the task to the appropriate section below
2. Include the task number, name, and completion date
3. Optionally add notes about any deviations or important implementation details

---

## Completed Tasks

### Infrastructure
- âœ… **01 â€“ Backend, Database & Docker Setup** (Completed: February 18, 2026)
  - **Architecture Refactored (February 18, 2026):** Migrated from entity-specific repository pattern to modern expression-based generic repository pattern
    - Removed virtual methods from Repository<T> base class
    - Updated IRepository<T>.GetAllAsync() to accept optional filter and orderBy expression parameters
    - Deleted entity-specific IMaintenanceTemplateRepository and MaintenanceTemplateRepository classes
    - Updated DI registration to use generic Repository<T> pattern
    - Moved sorting/filtering logic from repository to service layer (proper separation of concerns)
    - Updated all unit tests (32 tests passing - added 1 new filter test)
    - Benefits: More flexible, reusable, follows modern best practices, no need for entity-specific repositories
- âœ… **02 â€“ Frontend & Docker Setup** (Completed: February 18, 2026)

### Backend
- âœ… **01 â€“ GET Maintenance Templates** (Completed: February 18, 2026)
  - Implemented GET /api/setup endpoint to retrieve all maintenance templates
  - Sorting by CreatedAt descending (newest first) implemented using expression pattern in service layer
  - Returns 200 OK with array of MaintenanceTemplateDto (including archived templates)
  - Returns empty array [] with 200 OK when no templates exist
  - Implemented across 3-layer architecture:
    - Repository: Generic Repository<MaintenanceTemplate> with expression parameters for flexible querying
    - Service: GetAllTemplatesAsync() passes orderBy expression to repository and handles DTO mapping
    - Controller: HttpGet endpoint with proper error handling
  - **Unit Tests:** 32 total tests passing (9 Repository + 12 Service + 15 Controller)
    - Repository: Tests for CRUD operations, sorting with orderBy parameter, filtering with filter parameter, empty database
    - Service: Tests for DTO mapping, empty list handling, repository call verification
    - Controller: Tests for 200 OK responses, data return, empty array, error handling, service call verification
    - All tests use xUnit + Moq patterns with Arrange-Act-Assert structure
    - Repository tests use EF Core InMemory provider for complex query verification (Moq for simple CRUD)
  - Docker integration tested successfully - endpoint returns sorted results
- âœ… **02 â€“ POST Create Maintenance Template** (Completed: February 18, 2026)
  - Created MaintenanceTemplate entity with all required properties
  - Implemented 3-layer architecture (Controller â†’ Service â†’ Repository)
  - Added validation for required fields and interval type ("km" or "time")
  - Returns 201 Created with Location header
  - Created and applied EF Core migration
  - Tested successfully in docker-compose environment
  - **Unit Tests:** 21 tests implemented and passing (3 Repository + 8 Service + 10 Controller)
    - Test project: `CarMaintenanceTracker.Api.Tests` using xUnit and Moq
    - All tests follow Arrange-Act-Assert pattern
    - Code coverage report generated
- âœ… **03 â€“ PUT Update Maintenance Template** (Completed: February 18, 2026)
  - Implemented PUT /api/setup/{id} endpoint to update existing maintenance templates
  - All fields can be updated: name, intervalType, intervalValue, archived status
  - CreatedAt field is preserved during updates (not modified)
  - Returns 200 OK with updated MaintenanceTemplateDto on success
  - Returns 404 Not Found when template doesn't exist
  - Returns 400 Bad Request for validation errors (missing required fields, invalid interval type)
  - Implemented across 3-layer architecture:
    - Repository: Uses existing generic Repository<T> methods (GetByIdAsync, UpdateAsync)
    - Service: UpdateTemplateAsync checks existence, validates interval type, updates entity, maps to DTO
    - Controller: HttpPut endpoint with path parameter {id}, ModelState validation, proper error handling
  - Created UpdateMaintenanceTemplateDto with validation attributes
  - Interval type validation enforced ("km" or "time" only)
  - Tested successfully in docker-compose environment:
    - âœ… Successful updates return 200 OK with updated data
    - âœ… Non-existent templates return 404
    - âœ… Invalid interval type returns 400
    - âœ… Missing required fields return 400
    - âœ… Archived status can be toggled via update
    - âœ… CreatedAt timestamp preserved across updates
  - Build succeeds without warnings
- âœ… **06 â€“ GET Cars List** (Completed: February 18, 2026)
  - Implemented GET /api/cars endpoint to retrieve all cars with their maintenance items
  - Returns all cars sorted by CreatedAt descending (newest first)
  - Filters out maintenance items where the associated template is archived
  - Returns 200 OK with array of CarDto (or empty array if no cars exist)
  - Returns 500 Internal Server Error for unexpected errors
  - Implemented across 3-layer architecture:
    - Repository: Uses existing generic Repository<T> with expression-based filtering and ordering
    - Service: GetAllCarsAsync() retrieves cars with maintenance items, loads templates efficiently, filters archived templates, maps to DTOs
    - Controller: HttpGet endpoint with proper error handling and logging
  - Used existing DTOs: CarDto, CarMaintenanceItemDto (created in Task #07)
  - Architecture notes:
    - No entity-specific repository needed - leverages modern generic Repository<T> pattern
    - Service layer loads templates in batch queries to avoid N+1 issues
    - Filtering logic in MapCarToDto method: `.Where(mi => mi.MaintenanceTemplate != null && !mi.MaintenanceTemplate.Archived)`
    - Same filtering applies to both GET /api/cars and GET /api/cars/{id} endpoints
  - Tested successfully in docker-compose environment:
    - âœ… Returns all cars with maintenance items sorted by CreatedAt descending
    - âœ… Empty array returned when no cars exist
    - âœ… Maintenance items with archived templates are filtered out
    - âœ… Maintenance items include all required template details (name, interval type, value)
    - âœ… Next service calculations correct (km and date based)
    - âœ… GET /api/cars/{id} also filters archived templates correctly
    - âœ… No N+1 query issues - templates loaded efficiently in batch
  - All acceptance criteria met:
    - âœ… GET /api/cars returns all cars with maintenance items
    - âœ… Cars sorted newest first
    - âœ… Empty array returned when no data
    - âœ… Maintenance items include template details
    - âœ… Archived template items excluded
    - âœ… Returns 200 OK always
    - âœ… No business logic in controller
    - âœ… Repository pattern respected
  - Build succeeds without warnings
- âœ… **07 â€“ POST Create Car** (Completed: February 18, 2026)
  - Implemented POST /api/cars endpoint to create new cars with associated maintenance items
  - Created Car and CarMaintenanceItem entities with proper relationships
  - Returns 201 Created with Location header pointing to created resource
  - Returns 400 Bad Request for validation errors (missing required fields, negative mileage, invalid templates)
  - Returns 500 Internal Server Error for unexpected errors
  - Implemented across 3-layer architecture:
    - Repository: Created ICarRepository and CarRepository extending generic Repository<T>
      - CreateCarWithMaintenanceItemsAsync handles transactional creation (car + items as atomic operation)
      - GetCarWithMaintenanceItemsAsync loads car with maintenance items and template information
      - GetAllCarsWithMaintenanceItemsAsync returns all cars sorted by CreatedAt descending
    - Service: Created ICarService and CarService with business logic
      - Validates only non-archived templates can be assigned to cars
      - Calculates next service km/date based on interval type:
        - km-based: CalculatedNextKm = LastServiceKm + IntervalValue
        - time-based: CalculatedNextDate = LastServiceDate + IntervalValue days
      - Maps DTOs to entities and back with proper relationships
    - Controller: Created CarsController with POST, GET (all), GET (by id) endpoints
      - Returns 201 Created with Location header
      - Proper error handling and logging
  - Created DTOs:
    - CreateCarDto with nested CreateCarMaintenanceItemDto array
    - CarDto with nested CarMaintenanceItemDto array for responses
  - Validation rules enforced:
    - Name required â†’ "Name is obligatory field"
    - CurrentKm required â†’ "Mileage is obligatory field"
    - CurrentKm must be >= 0
    - MaintenanceItems array can be empty
    - For each maintenance item: MaintenanceTemplateId, IntervalValue (> 0), IntervalType ("km" or "time") required
    - Only non-archived templates can be assigned
  - Database:
    - Updated AppDbContext with Cars and CarMaintenanceItems DbSets
    - Configured entity relationships (Car â†’ CarMaintenanceItems, CarMaintenanceItem â†’ MaintenanceTemplate)
    - Created and applied migration: AddCarAndCarMaintenanceItemEntities
    - Foreign keys: CarId (CASCADE), MaintenanceTemplateId (RESTRICT)
  - Registered services in Program.cs (ICarRepository, ICarService)
  - Tested successfully in docker-compose environment:
    - âœ… Car created with maintenance items returns 201 with correct calculations
    - âœ… Next service km calculated correctly (km-based: 40000 + 10000 = 50000)
    - âœ… Next service date calculated correctly (time-based: 2025-06-15 + 365 days = 2026-06-15)
    - âœ… Car created with no maintenance items (empty array) works
    - âœ… Location header returned with correct URI
    - âœ… Validation errors return 400 (empty name, negative mileage, non-existent template)
    - âœ… Archived templates rejected with 400 error message
    - âœ… GET /api/cars returns all cars sorted by CreatedAt descending
    - âœ… GET /api/cars/{id} returns specific car with maintenance items
  - All acceptance criteria met
  - Build succeeds without warnings
  - Transaction atomicity verified (car + maintenance items created together or not at all)
- âœ… **11 â€“ GET Dashboard Data** (Completed: February 18, 2026)
  - Implemented GET /api/dashboard/{carId} endpoint to retrieve dashboard data with calculated maintenance status
  - Returns 200 OK with DashboardDto containing car details and maintenance items with status calculations
  - Returns 404 Not Found when car doesn't exist
  - Returns 500 Internal Server Error for unexpected errors
  - Implemented across 3-layer architecture:
    - Repository: Uses existing generic Repository<T> (no entity-specific repository needed)
    - Service: GetDashboardDataAsync() retrieves car with maintenance items, loads templates efficiently, calculates status dynamically, maps to DashboardDto
    - Controller: Created DashboardController with HttpGet endpoint, proper error handling and logging
  - Created DTOs:
    - DashboardDto with carId, carName, currentKm, and list of dashboard maintenance items
    - DashboardMaintenanceItemDto with all maintenance item fields plus calculated status, kmUntilDue, daysUntilDue
  - Status calculation logic implemented:
    - **km-based items:** kmUntilDue = calculatedNextKm - currentKm
      - Overdue: kmUntilDue < 0
      - DueSoon: 0 <= kmUntilDue <= 300
      - OK: kmUntilDue > 300
    - **time-based items:** daysUntilDue = (calculatedNextDate - Today).TotalDays
      - Overdue: daysUntilDue < 0
      - DueSoon: 0 <= daysUntilDue <= 30
      - OK: daysUntilDue > 30
  - Filters out maintenance items with archived templates (same logic as GetAllCars and GetCarById)
  - Tested successfully in docker-compose environment:
    - âœ… Dashboard data returned with correct car details
    - âœ… All maintenance items include calculated status fields
    - âœ… Status "OK" calculated correctly:
      - km-based: currentKm=50000, calculatedNextKm=55000 â†’ kmUntilDue=5000, status="OK" âœ“
      - time-based: calculatedNextDate=2026-06-15 (117 days from now) â†’ daysUntilDue=117, status="OK" âœ“
    - âœ… Status "DueSoon" calculated correctly:
      - km-based: currentKm=49800, calculatedNextKm=50000 â†’ kmUntilDue=200, status="DueSoon" âœ“
      - time-based: calculatedNextDate=2026-03-10 (20 days from now) â†’ daysUntilDue=20, status="DueSoon" âœ“
    - âœ… Status "Overdue" calculated correctly:
      - time-based: calculatedNextDate=2025-09-12 (159 days ago) â†’ daysUntilDue=-159, status="Overdue" âœ“
    - âœ… 404 error returned for non-existent car ID
    - âœ… Archived templates filtered out correctly
    - âœ… No N+1 query issues - templates loaded efficiently in batch
  - All acceptance criteria met:
    - âœ… GET /api/dashboard/{carId} returns dashboard data
    - âœ… Returns 200 OK with calculated status
    - âœ… Returns 404 if car not found
    - âœ… Status correctly calculated for km-based items (all 3 states tested)
    - âœ… Status correctly calculated for time-based items (all 3 states tested)
    - âœ… kmUntilDue / daysUntilDue calculated correctly
    - âœ… Archived template items excluded
    - âœ… No business logic in controller
    - âœ… Repository pattern respected
    - âœ… Build succeeds without warnings
  - Architecture compliance:
    - Service layer contains all business logic (status calculation)
    - Controller only handles HTTP concerns
    - Uses generic Repository<T> - no entity-specific repository needed
    - Async/await throughout
    - Proper error handling with specific status codes
    - Logging for debugging and monitoring

### Frontend
- âœ… **01 â€“ Display Maintenance Templates** (Completed: February 18, 2026)
  - Implemented GET /api/setup endpoint integration to fetch all maintenance templates
  - Created reusable components following feature-based architecture:
    - `EmptyState` component in `src/components/feedback/` for empty state display
    - `TemplateCard` component in `src/features/templates/components/` for individual template display
    - `TemplateList` component in `src/features/templates/components/` for template list rendering
  - Created `useFetchTemplates` custom hook in `src/features/templates/hooks/` for data fetching with loading/error states
  - Created `formatDate` utility in `src/utils/` for date formatting
  - Added `getAllMaintenanceTemplates()` function to templates API service
  - Updated SetupPage to display templates with loading, error, and empty states
  - Templates display all required information:
    - Template name with visual distinction for archived status (gray background + "Archived" badge)
    - Interval type (km/time) and value with appropriate labels
    - Created date formatted as readable string (e.g., "Feb 18, 2026")
    - Edit, Archive, and Restore buttons (placeholders for future tasks)
  - Automatic template list refresh after creating new template
  - Features implemented:
    - Loading spinner centered during fetch
    - Error notification with Alert component on API failure
    - Empty state message when no templates exist
    - Responsive card layout using Tailwind CSS
    - Proper sorting (newest first - handled by backend)
  - All acceptance criteria met
  - No TypeScript errors (strict typing enforced)
  - Successfully tested in dockerized environment (frontend + backend + database)
  - Templates fetch and render correctly with all fields displaying properly
- âœ… **02 â€“ Add Maintenance Template** (Completed: February 18, 2026)
  - Created AddTemplateForm component with modal UI
  - Implemented form validation with specific error messages
  - Added API service layer with fetch-based HTTP client
  - Created type definitions for MaintenanceTemplate and DTOs
  - Added /setup route with placeholder page
  - Form features:
    - Name, Interval Type (km/time), and Interval Value fields
    - Dynamic label showing "km" or "days" based on interval type
    - Real-time field validation and error display
    - Loading state with spinner during submission
    - Success notification on create
    - Server error handling (400, 500)
    - Duplicate submission prevention
  - All acceptance criteria met
  - TypeScript compilation successful (no errors)
  - Tested successfully in dockerized environment (frontend + backend + database)- âœ… **06 â€“ Add Car with Maintenance Items** (Completed: February 18, 2026)
  - Implemented POST /api/cars endpoint integration to create new cars with maintenance items
  - Created comprehensive type definitions and API layer:
    - `src/types/car.ts` with Car, CreateCarDto, and CreateCarMaintenanceItemDto interfaces
    - `src/features/cars/api/cars-api.ts` with createCar and getAllCars functions
    - Updated `src/constants/api-endpoints.ts` with CARS endpoint
  - Created cars feature folder structure following feature-based architecture:
    - **Hooks:**
      - `use-car-form.ts` - Complex form state management with Map-based selectedTemplates tracking
      - `use-create-car.ts` - API submission logic with success/error handling
    - **Components:**
      - `maintenance-item-selector.tsx` - Template selection with checkboxes, displays available non-archived templates
      - `maintenance-item-form.tsx` - Dynamic interval editing and last service inputs (km or date based on type)
  - Created reusable DateInput component (`src/components/ui/date-input.tsx`):
    - Implements dd/mm/yyyy input mask with automatic formatting
    - Removes non-numeric characters automatically
    - Formats as user types (dd â†’ dd/mm â†’ dd/mm/yyyy)
    - Includes validation and error display
  - Created AddCarPage (`src/pages/cars/add-car-page.tsx`):
    - Multi-section form layout (Car Details + Assign Maintenance Items)
    - Fetches non-archived templates on page load using useFetchTemplates hook
    - Template selection with checkboxes - shows template name and interval info
    - Dynamic maintenance item configuration section (only shows when templates selected)
    - Conditional last service inputs:
      - km-based templates: number input for lastServiceKm
      - time-based templates: date input with dd/mm/yyyy mask for lastServiceDate
    - Date format conversion: dd/mm/yyyy â†’ ISO 8601 format for backend
    - Comprehensive validation:
      - Name required â†’ "Name is obligatory field"
      - Mileage required â†’ "Mileage is obligatory field"
      - Mileage must be >= 0
      - Interval values must be > 0 for each selected item
      - Date validation: day <= 31, month <= 12, year >= 2000
    - Loading states with spinner during template fetch and car submission
    - Success notification "Car created successfully" with auto-navigation
    - Server error handling (400, 500) with user-friendly messages
    - Back button and Cancel button both navigate to /cars
    - Disable form inputs and buttons during submission
  - Created CarsListPage placeholder (`src/pages/cars/cars-list-page.tsx`):
    - Simple placeholder for redirect target (full implementation in Task #05)
    - Includes "Add Car" button for navigation to /cars/new
  - Updated router (`src/app/router.tsx`):
    - Added /cars route for CarsListPage
    - Added /cars/new route for AddCarPage
  - Form features:
    - Clean card-based UI with proper spacing and shadows
    - Responsive layout with max-width container
    - Clear section headers and descriptions
    - Dynamic labels showing "km" or "days" based on interval type
    - Collapsible selected items section with count display
    - Proper error message positioning under each field
    - Consistent button styling with loading states
  - Edge cases handled:
    - Creating car with no maintenance items (empty array) works correctly
    - No templates available shows empty state message
    - Archived templates properly excluded from selection
    - Invalid date formats caught by frontend validation
    - Backend validation errors properly displayed
    - Network errors handled gracefully
  - All acceptance criteria met:
    - âœ… Page accessible at /cars/new
    - âœ… Form displays correctly with all fields
    - âœ… Templates fetched and displayed
    - âœ… Archived templates excluded
    - âœ… All validations work with correct error messages
    - âœ… POST request creates car successfully
    - âœ… Navigates to /cars after success
    - âœ… Success notification shown
    - âœ… Cancel navigates back without saving
    - âœ… Date mask works correctly (dd/mm/yyyy)
    - âœ… Dynamic interval labels (km/days)
    - âœ… No console errors
    - âœ… No TypeScript errors
  - Tested successfully in dockerized environment (frontend + backend + database):
    - âœ… Car created with maintenance items returns 201 with correct data
    - âœ… Car created without maintenance items works
    - âœ… Non-archived templates fetched and displayed correctly
    - âœ… Date format conversion works (dd/mm/yyyy â†’ ISO 8601)
    - âœ… Next service calculations correct (verified via API)
    - âœ… Navigation to /cars works after successful creation
    - âœ… Validation errors display correctly
    - âœ… Loading states work properly
  - Architecture compliance:
    - Feature-based structure maintained
    - Separation of concerns (hooks, components, API layer)
    - Reusable components in proper locations
    - Type safety with strict TypeScript
    - Consistent styling with Tailwind CSS
    - No business logic in page components
- âœ… **05 â€“ Display Cars List** (Completed: February 18, 2026)
  - Implemented GET /api/cars endpoint integration on Cars page
  - Created reusable utility function:
    - `formatNumber` in `src/utils/format-number.ts` for mileage formatting with thousand separators (e.g., "52,000 km")
  - Created feature components following feature-based architecture:
    - `CarCard` component in `src/features/cars/components/` displays individual car information:
      - Car name (prominent bold heading)
      - Current mileage (formatted with thousand separators + " km")
      - Number of maintenance items
      - Created date (formatted as readable string)
      - Edit button (navigates to /cars/{id}/edit - placeholder for Task #07)
      - View Details button (placeholder for Task #08)
    - `CarList` component in `src/features/cars/components/` renders responsive grid layout of car cards
  - Created `useFetchCars` custom hook in `src/features/cars/hooks/` for data fetching with loading/error states
  - Updated CarsListPage to display full cars list with:
    - Automatic fetch on page load
    - Loading spinner centered during fetch
    - Error notification with clear message on API failure
    - Empty state message: "No cars available. Add your first car to get started."
    - Responsive grid layout (1 column mobile, 2 columns tablet, 3 columns desktop)
    - "Add Car" button at top (navigates to /cars/new)
  - Cars display all required information:
    - Car name most prominent (text-xl font-bold)
    - Current mileage formatted correctly (e.g., "50,000 km")
    - Maintenance items count
    - Created date formatted as readable string (e.g., "Feb 18, 2026")
  - Features implemented:
    - Loading state displayed during fetch (centered LoadingSpinner)
    - Error notification shown on failure (red alert box)
    - Empty state when no cars exist (EmptyState component)
    - Cars sorted by backend (newest first - CreatedAt descending)
    - Edit and View Details buttons on each card
    - Responsive card layout with proper spacing
    - Visual hierarchy with car name most prominent
  - All acceptance criteria met:
    - âœ… Page loads and fetches cars automatically
    - âœ… Cars render correctly with all required fields
    - âœ… Empty state shown when no cars exist
    - âœ… Add Car button navigates to /cars/new
    - âœ… Edit button navigates to /cars/{id}/edit
    - âœ… Loading state displayed during fetch
    - âœ… Error notification shown on failure
    - âœ… Sorting matches backend (newest first)
    - âœ… Mileage formatted correctly with thousand separators
    - âœ… No console errors
    - âœ… No TypeScript errors
    - âœ… Responsive on mobile and desktop
  - Edge cases handled:
    - Cars with no maintenance items display "0" count
    - Network failures show error message
    - Empty array response shows empty state
    - Backend errors (500) display error notification
  - Tested successfully in dockerized environment (frontend + backend + database):
    - âœ… Multiple cars displayed correctly in grid layout
    - âœ… All car fields render properly (name, mileage, maintenance count, date)
    - âœ… Mileage formatted with thousand separators (e.g., "50,000 km", "365,000 km")
    - âœ… Maintenance items count accurate for cars with/without items
    - âœ… Dates formatted correctly (e.g., "Feb 18, 2026")
    - âœ… Loading spinner shows during fetch
    - âœ… Empty state tested (displays correct message when no cars)
    - âœ… Edit button navigation works (routes to /cars/{id}/edit)
    - âœ… Add Car button works (routes to /cars/new)
    - âœ… Responsive layout verified (grid adjusts for different screen sizes)
    - âœ… Sorting verified (newest cars appear first)
  - Architecture compliance:
    - Feature-based structure maintained (cars feature folder)
    - Separation of concerns (useFetchCars hook, CarList/CarCard components, API layer)
    - Reusable utility functions in proper location (utils folder)
    - Type safety with strict TypeScript (no errors)
    - Consistent styling with Tailwind CSS
    - No business logic in page components (logic in hooks)
    - Follows same patterns as templates feature
- âœ… **09 â€“ Display Dashboard with Car Selector** (Completed: February 18, 2026)
  - Implemented GET /api/dashboard/{carId} endpoint integration with car selector dropdown
  - Created comprehensive dashboard feature following feature-based architecture:
    - **Types & API Layer:**
      - `src/types/dashboard.ts` - Dashboard and DashboardMaintenanceItem type definitions with status calculations
      - `src/features/dashboard/api/dashboard-api.ts` - getDashboardData() API function
      - Updated `src/constants/api-endpoints.ts` with DASHBOARD endpoint
    - **Custom Hooks:**
      - `useFetchDashboard` hook for fetching dashboard data with loading/error states
      - `useCarSelector` hook for managing car selection (auto-selects first car on load)
    - **Feature Components:**
      - `CarSelector` component - Dropdown for car selection using existing Select UI component
      - `DashboardHeader` component - Displays car name and current mileage (formatted with thousand separators)
      - `MaintenanceGroup` component - Status group container with color-coded sections (red/yellow/green)
      - `MaintenanceItemCard` component - Individual maintenance item card with all details
  - Created DashboardPage (`src/pages/dashboard/dashboard-page.tsx`):
    - Fetches all cars for dropdown selector on page load
    - Auto-selects first car by default
    - Fetches dashboard data when car is selected
    - Groups maintenance items by status (Overdue, DueSoon, OK)
    - Displays three color-coded sections with status icons (ðŸ”´, ðŸŸ¡, ðŸŸ¢)
    - Each section shows empty state when no items in that category
    - Loading states during cars fetch and dashboard data fetch
    - Error notifications for both cars and dashboard API failures
    - No cars state with message: "No cars available. Add a car first."
  - Updated router (`src/app/router.tsx`) to add /dashboard route
  - Maintenance item cards display all required information:
    - Template name (bold heading)
    - Interval info (e.g., "Every 10,000 km" or "Every 365 days")
    - Last service (km or date formatted)
    - Next due (km or date formatted)
    - Until due text (e.g., "5,000 km remaining" or "20 days remaining" or "159 days overdue")
    - Track Change button (placeholder for future task)
  - Status grouping logic:
    - **Overdue Section (Red):** Items with status "Overdue" (negative kmUntilDue or daysUntilDue)
    - **Due Soon Section (Yellow):** Items with status "DueSoon" (0-300 km or 0-30 days)
    - **OK Section (Green):** Items with status "OK" (> 300 km or > 30 days)
  - Features implemented:
    - Car selector prominently placed at top with label
    - Car selector disabled during dashboard data fetch
    - Dashboard header shows car name and formatted mileage
    - Color-coded section backgrounds and borders (red-50/300, yellow-50/300, green-50/300)
    - Status icons for visual distinction (ðŸ”´, ðŸŸ¡, ðŸŸ¢)
    - Responsive grid layout for maintenance items (1/2/3 columns)
    - Empty state for each section: "No items in this category"
    - Loading spinner centered during fetch operations
    - Error notifications with clear messages
    - Car selection triggers automatic data refresh
  - All acceptance criteria met:
    - âœ… Dashboard page loads correctly at /dashboard
    - âœ… Car selector displays all cars from backend
    - âœ… Default car selected on load (first car)
    - âœ… Dashboard data fetched for selected car
    - âœ… Maintenance items grouped correctly by status (Overdue, DueSoon, OK)
    - âœ… Each item displays all required information
    - âœ… Color coding works correctly (red/yellow/green)
    - âœ… Empty states shown for empty sections
    - âœ… Loading state displayed during fetch
    - âœ… Error notification shown on failure
    - âœ… No cars state handled correctly
    - âœ… Car selection triggers data refresh
    - âœ… No console errors
    - âœ… No TypeScript errors
    - âœ… Responsive on mobile and desktop
  - Edge cases handled:
    - No cars available shows empty state
    - Cars with no maintenance items show all three empty sections
    - API errors display error notifications
    - Network failures handled gracefully
    - Car selector updates trigger fresh dashboard fetch
    - Different interval types (km/time) display correctly
    - Negative values show as "overdue" instead of "remaining"
  - Tested successfully in dockerized environment (frontend + backend + database):
    - âœ… Dashboard page accessible at http://localhost:3000/dashboard
    - âœ… Car selector populated with 11 cars from database
    - âœ… First car auto-selected on page load
    - âœ… Dashboard data fetched correctly for selected car
    - âœ… All three status groups tested:
      - Overdue: Car 1006 shows Air Filter (-159 days overdue) in red section âœ…
      - DueSoon: Car 2002 shows Oil Change (200 km remaining) in yellow section âœ…
      - OK: Car 1 shows Annual Inspection (117 days remaining) in green section âœ…
    - âœ… Multiple items per car display correctly (Car 1006 has items in Overdue and OK sections)
    - âœ… Maintenance item details all display correctly:
      - Template names shown
      - Interval info formatted (e.g., "Every 10,000 km", "Every 365 days")
      - Last service formatted (km with thousand separators, dates as readable strings)
      - Next due formatted correctly
      - Until due text shows correct values with "remaining" or "overdue"
    - âœ… Empty sections show "No items in this category" message
    - âœ… No cars scenario tested (shows appropriate message)
    - âœ… Car selector dropdown functional and triggers data refresh
    - âœ… Loading spinners display during fetch operations
    - âœ… Color coding verified (red/yellow/green backgrounds and borders)
    - âœ… Status icons display correctly (ðŸ”´, ðŸŸ¡, ðŸŸ¢)
    - âœ… Responsive layout verified (grid adjusts for screen sizes)
    - âœ… TypeScript compilation successful (no errors)
    - âœ… Track Change buttons render on all items (placeholders for future task)
  - Architecture compliance:
    - Feature-based structure maintained (dashboard feature folder)
    - Separation of concerns (hooks for data fetching, components for presentation, API layer)
    - Page component thin - only orchestrates composition
    - Reusable UI components leveraged (Card, Select, Button, Container, LoadingSpinner, EmptyState)
    - Type safety with strict TypeScript (all interfaces properly defined)
    - Consistent styling with Tailwind CSS (color-coded sections, responsive grids)
    - No business logic in page components (status grouping in page, but simple filtering)
    - Follows established patterns from cars and templates features
    - Proper async/await error handling throughout